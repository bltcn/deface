/*** @author Steve Shipman* @version 0.1*/package com.suckatmath.detector{	import com.suckatmath.detector.classifier.HaarClassifier;	import com.suckatmath.detector.classifier.IntegralImage;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.IBitmapDrawable;	import flash.geom.Rectangle;	import flash.utils.getTimer;	/**	 * A Detector applies a HaarClassifier to an Image, getting back an Array of Rectangles representing matching areas of the image.	     */	public class BigToSmallDetector extends Detector	{		/**		 * 		 * @param hc  classifier determining feature(s) to recognize		 * @param md  maximum number of matching rectangles to return - May not correspond to actual distinct features as same feature		 * can be detected at multiple enclosing rectangles		 * @param minscale minimum of smallest dimension of classifier.		 */		public function BigToSmallDetector(hc:HaarClassifier = null, md:int = 1, minscale:int = 20):void		{			super(hc, md, minscale);		}		/**		 * Just like detect, but allows re-use of Integral Image for different detectors on the same image		 * 		 * scan classifier across ii at INCREASING scales, looking for objects.		 * increasing scale allows minimal rectangles to be found first, and prevent processing redundant rectangles.		 * Will find at most maxDetect faces.  If maxDetect == -1, find ALL.		 * 		 * @param ii:IntegralImage		 * @param boundaryRect:Rectangle - a rectangle describing the area of the image in which to look.  If null, entire image is used		 * 		 * @return Array of Rectangles describing areas where objects were found.		 */		public override function detectOnII(ii:IntegralImage, boundaryrect:Rectangle = null):Array		{			if (boundaryrect == null)			{				boundaryrect = new Rectangle(0, 0, ii.width -1, ii.height - 1);			}			var cw:int = classifier.width			var scale:Number = boundaryrect.width / cw;			if ((cw * scale)>>0 > boundaryrect.height)			{				scale = boundaryrect.height / cw;			}			var rectsize:int = (scale * cw)>>0			var rect:Rectangle = new Rectangle(0, 0, rectsize, rectsize);			var ret:Array = new Array();			var s:int = rectsize;			do			{				classifier.setScale(rect);				scanImage(classifier, ii, rect, boundaryrect, ret);				if ((md != -1) && (ret.length >= md))				{					trace("md: " + md);					return ret;				}				s -= 8; //TUNABLE, in concert with tracker min size				rect.width=rect.height=s			} while (s >= minscale);			if (ret.length > 0) {				return ret;			}			return null;		}	}}